Problem : Given an integer array arr[] and a number k. Find the count of distinct elements in every window of size k in the array.

Examples:

Input: arr[] = [1, 2, 1, 3, 4, 2, 3], k = 4
Output:  [3, 4, 4, 3]
Explanation: Window 1 of size k = 4 is 1 2 1 3. Number of distinct elements in this window are 3. 
Window 2 of size k = 4 is 2 1 3 4. Number of distinct elements in this window are 4.
Window 3 of size k = 4 is 1 3 4 2. Number of distinct elements in this window are 4.
Window 4 of size k = 4 is 3 4 2 3. Number of distinct elements in this window are 3.


Input: arr[] = [4, 1, 1], k = 2
Output: [2, 1]
Explanation: Window 1 of size k = 2 is 4 1. Number of distinct elements in this window are 2. 
Window 2 of size k = 2 is 1 1. Number of distinct elements in this window is 1. 





ðŸ§  Understanding the Problem:
You have to check each window of size k and count how many unique numbers are present in that window.

ðŸ”§ Approach 1: Brute Force using HashSet
âž¤ Steps:
Traverse from index 0 to n-k.

For each window of size k, insert all elements into a HashSet.

Since HashSet contains only unique values, set.size() gives count of distinct elements.

Clear the set before moving to the next window.

ðŸ’» Java Code:
ArrayList<Integer> result = new ArrayList<>();
HashSet<Integer> count = new HashSet<>();

for (int i = 0; i <= arr.length - k; i++) {
    for (int j = i; j < i + k; j++) {
        count.add(arr[j]);
    }
    result.add(count.size());
    count.clear();
}
â±ï¸ Time Complexity:
Outer loop: O(n - k + 1)

Inner loop: O(k)

Total = O(n * k)

ðŸ“¦ Space Complexity:
O(k) for HashSet

âœ… Pros:
Simple and intuitive

Easy to implement

âŒ Cons:
Inefficient for large arrays




âš™ï¸ Approach 2: Optimized using HashMap + Sliding Window
âž¤ Key Idea:
Track frequency of elements in the current window using a HashMap. Slide the window by one element at a time, update the map, and keep track of unique elements.

âž¤ Steps:
Use HashMap<Integer, Integer> to store frequencies.

Process the first window (first k elements).

Then slide the window:

Remove the outgoing element (reduce freq / remove from map if freq == 0)

Add the incoming element (increase freq)

Map size gives the number of distinct elements in the window.

ðŸ’» Java Code:
ArrayList<Integer> result = new ArrayList<>();
HashMap<Integer, Integer> freqMap = new HashMap<>();

// First window
for (int i = 0; i < k; i++) {
    freqMap.put(arr[i], freqMap.getOrDefault(arr[i], 0) + 1);
}
result.add(freqMap.size());

// Slide window
for (int i = k; i < arr.length; i++) {
    int out = arr[i - k];
    freqMap.put(out, freqMap.get(out) - 1);
    if (freqMap.get(out) == 0) freqMap.remove(out);

    freqMap.put(arr[i], freqMap.getOrDefault(arr[i], 0) + 1);
    result.add(freqMap.size());
}
â±ï¸ Time Complexity:
Each element is added and removed once â†’ O(n)

ðŸ“¦ Space Complexity:
O(k) for HashMap

âœ… Pros:
Efficient for large datasets

Perfect use-case for sliding window + hashing

âš–ï¸ Comparison Table:
Feature	Brute Force (HashSet)	Optimized (HashMap)
âœ… Correctness	âœ”ï¸	âœ”ï¸
â±ï¸ Time Complexity	âŒ O(n * k)	âœ… O(n)
ðŸ’¾ Space Complexity	O(k)	O(k)
ðŸ” Suitable for large n	âŒ No	âœ… Yes
ðŸ’¡ Technique Used	HashSet	HashMap + Sliding

ðŸ“Œ Final Takeaways:
Always start with a brute force approach to understand the logic.

Optimize using sliding window + hashmap when performance matters.

Practice this type of pattern to tackle many other problems (like max/min/average in window).

ðŸ”„ Related Problems:
First negative integer in every window of size k

Maximum element in every window

Longest subarray with k distinct elements
