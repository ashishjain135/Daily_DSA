# day52 arr[i]+arr[j]<target

**Topic:** Count Pairs whose Sum is Less than Target

**Technique:** Sorting + Two Pointer

Problem : 

### **Count Pairs whose sum is less than target**

Given an arrayÂ **arr[]**Â and an integerÂ **target**.Â You have to find the number of pairs in the array whose sum is strictly less than theÂ **target**.

Example: 

```
Input:arr[] = [2, 1, 8, 3, 4, 7, 6, 5], target = 7
Output:6
Explanation:There are 6 pairs whose sum is less than 7: (2, 1), (2, 3), (2, 4), (1, 3), (1, 4) and (1, 5).
```

---

### ğŸ”¶ **Problem Understanding:**

- Given: Array `arr[]` of size `n` and integer `target`.
- Task: Count the number of pairs `(i, j)` such that:
    
    ```
    css
    CopyEdit
    arr[i] + arr[j] < target
    i < j
    
    ```
    

---

### ğŸ”¶ **Naive Approach (Brute Force):**

- Use two nested loops to check every pair.
- Count if sum < target.

```java
java
CopyEdit
int count = 0;
for(int i=0; i<n; i++){
    for(int j=i+1; j<n; j++){
        if(arr[i] + arr[j] < target)
            count++;
    }
}

```

**Time Complexity:**

- O(NÂ²) â†’ Not optimal for large inputs.

---

### ğŸ”¶ **Optimized Approach (Two Pointer + Sorting):**

### ğŸ”¸ **Core Idea:**

- Sort the array first:
    
    `Arrays.sort(arr);`
    
- Initialize two pointers:
    
    `i = 0`, `j = n-1`
    
- Iterate while `i < j`:
    - If `arr[i] + arr[j] < target`
        
        â†’ All pairs between `i` and `j` are valid
        
        â†’ Add `(j - i)` to count
        
        â†’ Move `i++` (because increasing i can still give valid pairs)
        
    - Else `j--` (to decrease sum)

---

### ğŸ”¸ **Pseudocode:**

```java
java
CopyEdit
sort(arr);
i = 0; j = n-1;
count = 0;

while(i < j):
    if(arr[i] + arr[j] < target):
        count += (j - i)
        i++
    else:
        j--

```

---

### ğŸ”¸ **Time Complexity:**

- Sorting: O(N log N)
- Two Pointer: O(N)
- **Total: O(N log N)** âœ…

### ğŸ”¸ **Space Complexity:**

- O(1) (In-place sorting if allowed)

---

### ğŸ”¶ **Why Sorting Works?**

- After sorting:
    
    ```
    CopyEdit
    arr[0] <= arr[1] <= ... <= arr[n-1]
    
    ```
    
- If `arr[i] + arr[j] < target`, then any value between `arr[i]` and `arr[j-1]` also gives valid pairs with `arr[i]`.
- No need to check individually â€” count all together using `(j - i)`.

---

### ğŸ”¶ **Example Dry Run:**

**Input:**

arr = [7, 2, 5, 3], target = 8

**Step 1:** Sort â†’ [2, 3, 5, 7]

i = 0, j = 3, count = 0

- arr[0] + arr[3] = 2 + 7 = 9 (> 8) â†’ j--
- arr[0] + arr[2] = 2 + 5 = 7 (< 8) â†’ count += (2 - 0) = 2 â†’ i++
- arr[1] + arr[2] = 3 + 5 = 8 (not less than target) â†’ j--

**Final Count = 2**

---

### ğŸ”¶ **Edge Cases to Remember:**

- Empty array â†’ count = 0
- Array with single element â†’ count = 0
- Duplicate elements â†’ logic still works correctly

---

### ğŸ”¶ **Key Learnings Today:**

- Two pointer problems almost always require sorted arrays.
- Always think if pairs can be counted in groups instead of one-by-one.
- `count += (j - i)` trick is very powerful in pair-sum type problems.

---

### ğŸ”¶ **Variants of this Problem:**

| Variant | Approach |
| --- | --- |
| Count pairs with sum **equal** to target | HashMap / Binary Search |
| Count pairs with sum **greater** than target | Same two pointer with reverse condition |
| Count unique pairs (no duplicates) | Set usage |

---

âœ… **Mastered Today:**

Two Pointer + Sorting + Pair Count Optimization ğŸš€
