# **CntPrsGivenSum  ->> Count pairs with given sum**

## âœ… Problem Statement:

Given an array `arr[]` and an integer `target`, count the number of **pairs (i, j)** such that:

`arr[i] + arr[j] == target`

and `i < j`.

---

## ğŸ” Examples:

### â¤ Example 1:

**Input:** `arr = [1, 5, 7, -1, 5], target = 6`

**Output:** `3`

**Explanation:** Pairs â†’ (1,5), (7,-1), (1,5 again)

### â¤ Example 2:

**Input:** `arr = [1, 1, 1, 1], target = 2`

**Output:** `6`

**Explanation:** 4 elements â†’ C(4,2) = 6 valid pairs of (1,1)

---

## ğŸ’¡ Naive Approach (Brute Force):

### â¤ Logic:

Use 2 nested loops and check every possible pair.

### â¤ Code (Java):

```java
java
CopyEdit
int countPairs(int arr[], int target) {
    int count = 0;
    for(int i = 0; i < arr.length; i++) {
        for(int j = i + 1; j < arr.length; j++) {
            if(arr[i] + arr[j] == target)
                count++;
        }
    }
    return count;
}

```

### â±ï¸ Time Complexity:

- **O(nÂ²)** â€“ not suitable for large arrays

---

## âœ… Optimized Approach (Using HashMap):

### â¤ Key Idea:

- Use a **HashMap** to keep track of the **frequency of elements seen so far**
- For every element `x`, check how many times `target - x` has already occurred

---

### ğŸ§  Intuition:

Letâ€™s say:

- We encounter element `x`
- Complement needed is `target - x`
- If weâ€™ve already seen this complement, we can form a valid pair

---

### ğŸ”§ Java Code:

```java
java
CopyEdit
import java.util.HashMap;

int countPairs(int arr[], int target) {
    HashMap<Integer, Integer> map = new HashMap<>();
    int count = 0;

    for (int num : arr) {
        int complement = target - num;

        if (map.containsKey(complement)) {
            count += map.get(complement); // add all the complement matches
        }

        // increment current number's frequency
        map.put(num, map.getOrDefault(num, 0) + 1);
    }

    return count;
}

```

---

## ğŸ“ˆ Dry Run Example:

### For arr = [1, 5, 7, -1, 5], target = 6:

| num | complement | map (before) | count |
| --- | --- | --- | --- |
| 1 | 5 | {} | 0 |
| 5 | 1 | {1:1} | 1 |
| 7 | -1 | {1:1, 5:1} | 1 |
| -1 | 7 | {1:1, 5:1, 7:1} | 2 |
| 5 | 1 | {1:1, 5:1, 7:1, -1:1} | 3 |

âœ… Final Answer = 3

---

## âš™ï¸ Time & Space Complexity:

| Metric | Value |
| --- | --- |
| â± Time | O(n) |
| ğŸ§  Space | O(n) (HashMap) |

---

## âš ï¸ Edge Cases to Handle:

- Duplicate elements
- Negative numbers
- No valid pairs â†’ output `0`
- Large arrays â†’ prefer `O(n)` solution

---

## ğŸ“Œ Notes for Interview:

- Clarify if elements are **distinct** or **can repeat**
- Ask if we need **(i, j) indices** or just **count**
- Be ready to explain why HashMap works better than HashSet here

---

## âœ… Summary:

- **Brute Force** â†’ O(nÂ²), check all pairs
- **Optimized with HashMap** â†’ O(n), track frequency of complements
- Handle **duplicates carefully**
- One of the most asked **array pair-sum** pattern questions in interviews
