## ğŸ”¥ Problem Statement:

Given an array of strings, group all anagrams together.

Strings inside each group must follow the order of their appearance.

### âœ… Example:

Input:

```
arduino
CopyEdit
arr[] = ["act", "god", "cat", "dog", "tac"]

```

Output:

```
css
CopyEdit
[["act", "cat", "tac"], ["god", "dog"]]

```

---

## ğŸ”‘ Key Concepts:

- **Anagrams**: Strings that contain same characters but in different order.
    - `"act"`, `"cat"`, `"tac"` â†’ all anagrams because they have same characters.
- **Sorting a string** gives a unique signature to all its anagrams.
- Use **HashMap** (or `LinkedHashMap` in Java) to store:
    - Key â†’ Sorted string
    - Value â†’ List of original strings that match this anagram
- `LinkedHashMap` preserves insertion order of keys â†’ solves "maintain order of appearance" requirement.

---

## ğŸ’¡ Approach (Step-by-Step):

1ï¸âƒ£ Initialize a HashMap (`LinkedHashMap`) â†’ key: sorted string, value: list of strings.

2ï¸âƒ£ Iterate over each string in the array.

3ï¸âƒ£ For each string:

- Convert it into char array â†’ sort â†’ convert back to string â†’ get sorted version.
- This sorted version will act as key.

4ï¸âƒ£ Check if key exists in map:

- If not, create a new list.
- Add the original string into the corresponding list.

5ï¸âƒ£ After processing all strings, collect all lists from map â†’ output.

---

## ğŸ”§ Java Code:

```java
java
CopyEdit
import java.util.*;

class Solution {
    public ArrayList<ArrayList<String>> anagrams(String[] arr) {
        Map<String, List<String>> map = new LinkedHashMap<>();

        for (String str : arr) {
            char[] chars = str.toCharArray();
            Arrays.sort(chars);
            String sorted = new String(chars);

            if (!map.containsKey(sorted)) {
                map.put(sorted, new ArrayList<>());
            }
            map.get(sorted).add(str);
        }

        ArrayList<ArrayList<String>> result = new ArrayList<>();
        for (List<String> group : map.values()) {
            result.add(new ArrayList<>(group));
        }
        return result;
    }
}

```

---

## ğŸ§® Time & Space Complexity:

| Complexity | Analysis |
| --- | --- |
| **Time** | O(N * M log M) |
| **Space** | O(N * M) |

Where:

- N = number of strings
- M = average length of strings
- Sorting each string takes O(M log M).

---

## âš ï¸ Common Mistakes:

- Forgetting to preserve order â†’ use `LinkedHashMap`.
- Type mismatch when converting `List<List<String>>` to `ArrayList<ArrayList<String>>`.
- Sorting issue: Not converting string properly before/after sorting.

---

## ğŸ¯ Key Interview Points:

- Why sorting is used to detect anagrams?
- Why `LinkedHashMap` is better than `HashMap` here?
- How to convert nested collections safely in Java?
- Time complexity analysis.

---

## ğŸ” Variations to Practice:

- Group anagrams but don't care about order.
- Return count of anagram groups.
- Anagram substring search in larger string.

---

# âœ… Quick Template for Java Interview:

```java
java
CopyEdit
char[] chars = str.toCharArray();
Arrays.sort(chars);
String sorted = new String(chars);

```

- This is your **standard signature extraction** for anagrams.

---

# ğŸ”¥ Short Summary:

**Sort the string â†’ store into map â†’ collect values â†’ done.**

---

---
